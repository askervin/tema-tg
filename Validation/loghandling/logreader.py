#!/usr/bin/env python
# coding: utf-8
# Copyright (c) 2006-2010 Tampere University of Technology
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
Reads a log generated by TemaTool, and prints some info about it.

Usage: logreader [logfile(s)] [options]

If no logfiles given, reads from standard input.

Examples:

Help:
logreader -h

Default info about logfile:
logreader file.log

Print info in gnuplot datafile format, with "sample rate" of 10 seconds:
logreader file.log --gnuplot -r 10s > datafile.plotdat

You can gnuplot the resulting datafile(s) with tema plotter script.
The plotter also reads stdin, so this is possible:
logreader file.log --gnuplot | plotter | gnuplot -persist
"""

# TODO? refactor?
# It'd be better to first do some kind of lexical reading to get the
# transitions etc in a more handlable form, and then another pass on those to
# extract the needed info. Now it's all done in one big mess...
# That'd make it easier to do some kind of analysis of simultaneously
# running (shared coverage) kinda test runs, for example.
# (Don't think anybody'd want to refactor this though :)

import sys
import re
import datetime
import time
import math
import os

import optparse
from copy import copy
import csv

def ratio(val, perVal, NA=None):
    if perVal != 0:
        return float(val)/perVal
    else:
        return NA

def percentage(val, perVal, NA=None):
    r = ratio(val,perVal,NA)
    return r*100.0 if r is not NA else NA

def sumOfValues(someDict):
    return sum(someDict.values())

def numberOfNonZeros(someDict):
    num = 0
    for et in someDict.itervalues():
        if et > 0:
            num += 1
    return num

def nonZeroValuesRatio(awDict):
    if not awDict:
        return 0 # ?
    return float(numberOfNonZeros(awDict)) / len(awDict)

def timediffInMs(td):
    return (td.days * 24 * 3600 + td.seconds) * 1000 \
         + td.microseconds / 1000

def groupByTimesExecuted(d):
    counter = {}
    for x,n in d.iteritems():
        if n in counter:
            counter[n].append(x)
        else:
            counter[n] = [x]
    clist = [x for x in counter.iteritems()]
    clist.sort()
    return clist


def readSysArgs(argv):

    usage = "%prog [logfile(s)] [options]"
    description = "If no filenames are given or filename is -, reads from standard input"

    def zekkaa(option, opt, value):
        try:
            num,unit = value[:-1],value[-1]
            if unit not in "tsark%":
                return float(value),"s"
            elif unit == "%": return float(num),unit
            elif unit == "s": return float(num),unit
            elif unit == "a": return int(num),unit
            elif unit == "r": return int(num),unit
            elif unit == "k": return int(num),unit
            elif unit == "t": return int(num),unit
        except ValueError:
            raise optparse.OptionValueError("Invalid datarate value: %s"%value)
    class MyOption(optparse.Option):
        TYPES = optparse.Option.TYPES + ("tsark%",)
        TYPE_CHECKER = copy(optparse.Option.TYPE_CHECKER)
        TYPE_CHECKER["tsark%"] = zekkaa

    op = optparse.OptionParser(usage=usage, option_class=MyOption,description=description)
    op.add_option("--verbose", action="store_true",
                  help="verbose")
    op.add_option("--apps", action="store", type="str",
                  help="Application names. They're used to guess which aw belongs to which app.")
    op.add_option("--neg", action="store_true",
                  help="negative action words separately")
    op.add_option("--delay", action="store", type="float",
                  help="simulate delay for keyword execution (in seconds)")
    op.add_option("--gen", action="store_true",
                  help="read the TaskSwitcherGEN and TargetSwitcher aw's too. they're ignored by default")
    op.add_option("--comptrans", action="store", type="str",
                  help="Indices of components whose transitions to count.")
    op.add_option("--awexec", action="store_true",
                  help="Print how many times each aw is executed.")
    op.add_option("--gnuplot", action="store_true",
                  help="output in gnuplot datafile format.\
                  columns are described in comments of the datafile.")
    op.add_option("--csv", action="store_true",
                  help="Output in csv format.\
                  First row has column names.")
    op.add_option("-r", "--datarate", action="store", type="tsark%",
                  help="(with --gnuplot or --csv) determines the \"sample rate\" of datafile. Example values: 1.0s (seconds), 10a (action words), 10k (keywords), 1.5% (aw-coverage), 1000r (logfile rows), 1000t (transitions)")
    op.add_option("-l", "--datalimit", action="store", type="tsark%",
                  help="stop after given amount of time/AW's/KW's/cov.\
                  Same format as in --datarate")
    op.add_option("--combine", action="store_true",
                  help="Treat all the given logs as one big log.")
    op.add_option("--title", action="store", type="str")

    options, args = op.parse_args(argv[1:])

    mutuallyExclusive = (('gnuplot','verbose'),
                         ('gnuplot','awexec'),
                         ('gnuplot','csv'),
                         ('csv','verbose'),
                         ('csv','awexec'))
    for o1,o2 in mutuallyExclusive:
        if getattr(options,o1) and getattr(options,o2):
            op.error('options --%s and --%s are mutually exclusive' % (o1,o2))

    # if no filename given, read from stdin
    if len(args) == 0:
        logfiles = [sys.stdin]
    #elif len(args) == 1 and args[0] == "-":
    #    logfiles = [sys.stdin]
    else:
        try:
            logfiles = [file(fn,'r') if fn!='-' else sys.stdin for fn in args]
        except IOError,ioe:
            op.error(ioe)

    if options.delay:
        delay = datetime.timedelta(seconds=options.delay)
        options.delay = delay

    return logfiles, options


# regex of end_aw
# 4 groups: start of aw, sign("~" or ""), end of aw, param
_RE_END_AW = re.compile("(\S*:)(~?)(end_aw[^\s<]*)((?:<[^>]*>)?)")

_RE_START_AW = re.compile("(\S*:)(~?)(start_aw[^\s<]*)((?:<[^>]*>)?)")

_RE_ACTIVATES = re.compile("Executing: (.*) ACTIVATES (.*)")

_RE_WAKE = re.compile("Executing: WAKEtsWAKE<(.*)>")

# 2 groups: (appname, list of aw's separated by ",")
#_RE_BENCHMARKED = re.compile("Benchmarked app: (.*); Action words: (.*)$")
_RE_BENCHMARKED = re.compile("Action words: (.*)$")

_TIME_FORMAT = "%m%d%H%M%S"

class LogFileError(Exception):
    pass

def createTimeToStopFunc(unit,limit):
    if unit == 'a': return lambda rdr: rdr._numAWsOfCurrFileOnly >= limit
    elif unit == 'k': return lambda rdr: rdr._numKWsOfCurrFileOnly >= limit
    elif unit == '%': return lambda rdr: rdr.awCoverage()*100.0 >= limit
    elif unit == 's': return lambda rdr: rdr.elapsedMs()/1000 >= limit
    elif unit == 'r': return lambda rdr: rdr._rowsReadOfCurrFileOnly >= limit
    elif unit == 't': return lambda rdr: rdr._numTransOfCurrFileOnly >= limit
    assert False

def createTimeToPrintFunc(unit):
    if unit == 'a':
        return lambda rdr,val: rdr._numAWsOfCurrFileOnly >= rdr.nextPrint
    elif unit == 'k':
        return lambda rdr: rdr._numKWsOfCurrFileOnly >= rdr.nextPrint
    elif unit == '%':
        return lambda rdr: rdr.awCoverage()*100.0 >= rdr.nextPrint
    elif unit == 's':
        return lambda rdr: rdr.elapsedMs()/1000 >= rdr.nextPrint
    elif unit == 'r':
        return lambda rdr: rdr._rowsReadOfCurrFileOnly >= rdr.nextPrint
    elif unit == 't':
        return lambda rdr: rdr._numTransOfCurrFileOnly >= rdr.nextPrint
    assert False

class LogParser:

    def __init__(self, options):
        self.OPTIONS = options

        if self.OPTIONS.datalimit:
            limit, unit = self.OPTIONS.datalimit
            self.timeToStopFunc = createTimeToStopFunc(unit,limit)
        else:
            self.timeToStopFunc = lambda self: False

        if self.OPTIONS.datarate:
            rate, unit = self.OPTIONS.datarate
            self.timeToPrintFunc = createTimeToPrintFunc(unit)
        else:
            self.timeToPrintFunc = lambda self: True

        if self.OPTIONS.apps:
            self.appNames = self.OPTIONS.apps.strip().split()
        else:
            self.appNames = []

    def _reset(self):

        self._rowsRead = 0

        self.dataRows = []

        self._numKWs = 0

        self._numAWs = 0 # number of end_aw executions

        self.genAWs = set()

        # Action word "AW" of app "AppName" has been executed
        # *AWS_BY_APP["AppName"]["AW"] times.
        # positive AWs here:
        self._posAWsByApp = {}
        for an in self.appNames:
            self._posAWsByApp[an] = set()
        # negative AWs here, only used if OPTIONS.neg is True:
        if self.OPTIONS.neg:
            self._negAWsByApp = {}
            for an in self.appNames:
                self._negAWsByApp[an] = set()

        self._posAWs = None
        self._negAWs = None

        # key: state(tuple), value: how many times visited
        self._states = {}

        # transition = (state,kw/aw+params,state)
        # key: transition(tuple), value: how many times visited
        self._transitions = {}
        self._numTrans = 0

        # the transition that's been started but not finished
        self._current_transition = [None]

        # when the execution started
        self._startTime = None
        # the latest time
        self._latestTime = None
        # total delay of keyword executions so far
        self._delayByNow = datetime.timedelta() 

        self._asps = set()
        self._latestStartAW = None

        self.switchTransitions = set()

        self._currApp = None
        self._switchFrom = None
        self._switchFromState = None

        self.numSwitches = 0

        self.switchApps = []

        self._device = None

        # state length, for checking it doesn't increase because of a nondeterminism bug
        self._stateLen = None

        self._componenttransitions = set()
        self._numComponenttransitions = 0

        self._transitionsByComponent = {}
        self._numTransitionsByComponent = {}
        if self.OPTIONS.comptrans:
            for i in [int(si) for si in self.OPTIONS.comptrans.strip().split()]:
                self._transitionsByComponent[i] = set()
                self._numTransitionsByComponent[i] = 0

        self._resetCurrFile()

    def _resetCurrFile(self):
        self._startTime = None
        self._latestTime = None
        self._delayByNow = datetime.timedelta()
        self._current_transition = [None]
        self._currApp = None

        self._rowsReadOfCurrFileOnly = 0
        self._numKWsOfCurrFileOnly = 0
        self._numAWsOfCurrFileOnly = 0
        self._numTransOfCurrFileOnly = 0


    def readLog(self,logfile):

        self._reset()

        try:
            self._parseLogFile(logfile)
        except LogFileError, lfe:
            print >> sys.stderr, "Error when reading '%s'! (%i lines read)"%(logfile.name,self._rowsReadOfCurrFileOnly)
            if str(lfe): print >> sys.stderr, "%s"%lfe
            return False
        finally:
            logfile.close()
        return True

    def readLogsAsOne(self,logfiles):

        self._reset()

        for i,logfile in enumerate(logfiles):
            try:
                firstOne = (i == 0)
                lastOne = (i == len(logfiles)-1)
                self._resetCurrFile()
                self._parseLogFile(logfile, firstOne, lastOne)
            except LogFileError, lfe:
                print >> sys.stderr, "Error when reading '%s'! (%i lines read)"%(logfile.name,self._rowsReadOfCurrFileOnly)
                if str(lfe): print >> sys.stderr, "%s"%lfe
                return False
            finally:
                logfile.close()
        return True



    def _parseLogFile(self, logfile,firstOfCombined=True,lastOfCombined=True):
        """Parses a log file.

        Prints the results according to options given to constructor.
        """

        self.filename = logfile.name

        LINE_ACTIONWORDS = "Action words: "
        LINE_EXECUTING = "TestEngine: Executing"
        LINE_STATE = "TestEngine: New state: "
        LINE_ASP = "(Non-SleepState) StateProps: "

        headerHasToBePrinted = firstOfCombined
        self.rowWriter = None
        printDataRows = False

        if self.OPTIONS.datarate:
            num,unit = self.OPTIONS.datarate
            self.nextPrint = num
            nextPrintIncr = num
        else:
            self.nextPrint = None

        if self.OPTIONS.gnuplot:
            printDataHeader = self.printPlotDataComment
            printDataRow = self.printPlotDataRow
            printDataRows = True
        elif self.OPTIONS.csv:
            printDataHeader = self.printCSVDataHeader
            printDataRow = self.printCSVDataRow
            self.rowWriter = csv.writer(sys.stdout)
            printDataRows = True

        for line in logfile:
            # Just storing, not parsing the timeStr here.
            # It's parsed only when needed, to save time...
            # (Parsing time string was one of the most time consuming parts,
            # and it made reading very long logfiles slow...)
            self.timeStr = line[:14]
            if self._startTime is None:
                self._startTime = self._getLatestTime()

            start = time.time()
            if line.find(LINE_ACTIONWORDS) != -1:
                # Parse the list of all the aw's if not already.
                # (To only do it once for multiple combined logs, etc.)
                if self._posAWs is None:
                    self.parseActionWords(line)
            elif line.find(LINE_STATE) != -1:
                self.parseState(line)
            elif line.find(LINE_ASP) != -1:
                self.parseASP(line)
            elif line.find(LINE_EXECUTING) != -1:
                self.parseExecuting(line)

            self._rowsRead += 1
            self._rowsReadOfCurrFileOnly += 1

            if self.timeToStopFunc(self):
                break

            if printDataRows:
                try:
                    if headerHasToBePrinted:
                        printDataHeader()
                        headerHasToBePrinted = False
                        printDataRow()
                    elif self.timeToPrintFunc(self):
                        printDataRow()
                        if self.nextPrint is not None:
                            self.nextPrint += nextPrintIncr
                except IOError:
                    pass # ?

        if printDataRows and not headerHasToBePrinted:
            printDataRow()
            if lastOfCombined:
                # empty line marks the end of data, for --gnuplot at least...
                print 

        self.checkThatLogFileWasValid()

        if not printDataRows and lastOfCombined:
            self.printSummary()

    def _getLatestTime(self):
        try:
            dateStr,msStr = self.timeStr.split('.')
        except ValueError:
            # The latest line doesn't contain time stamp.
            # All the tema log lines do, but there could be some other lines
            # in the logfile.
            # Using the latest time.
            return self._latestTime

        # Python 2.4 doesn't have datetime.strptime function, but this does
        # same thing
        t = datetime.datetime(*(time.strptime(dateStr,_TIME_FORMAT)[0:6]))
        micros = int(msStr) * 1000
        self._latestTime = t.replace(microsecond=micros)
        return self._latestTime


    def elapsedMs(self):
        execTime = self._getLatestTime()
        elapsed = execTime - self._startTime + self._delayByNow
        return timediffInMs(elapsed)




    def parseActionWords(self,line):
        """Parses a "Action words:" line."""
        words = _RE_BENCHMARKED.search(line).groups()[0]
        if words:
            AWs = words.split()
            if not self.OPTIONS.gen:
                AWs = [w for w in AWs if not self.isGenAW(w)]
            self._posAWs = dict(zip(AWs,[0]*len(AWs)))
            for aw in AWs:
                app = self.appOfAW(aw)
                if app is not None:
                    self._posAWsByApp[app].add(aw)
            for appname,appAWs in self._posAWsByApp.iteritems():
                if not appAWs:
                    raise LogFileError("There are no action words belonging to app '%s'!"%appname)

            if self.OPTIONS.neg:
                negAWs = [self.negAWfromAW(aw) for aw in AWs]
                self._negAWs = dict(zip(negAWs,[0]*len(negAWs)))
                for naw in negAWs:
                    app = self.appOfAW(naw)
                    if app is not None:
                        self._negAWsByApp[app].add(naw)

    def parseState(self, line):
        """Parses a "New state" line."""

        stateStr = line.split("TestEngine: New state: ")[-1].strip()
        state = tuple([int(i) for i in stateStr[1:-1].split(', ')])

        # the state looks like a python tuple, so we'll just exec it (slow?)
        #exec "state = %s" % state

        if self._stateLen is None:
            self._stateLen = len(state)
        elif self._stateLen != len(state):
            raise LogFileError("State id lengths vary! Nondeterminism bug in the model?")

        if self._switchFrom != self._currApp:
            self.switchTransitions.add(
                (self._switchFromState,self._switchFrom,
                 state, self._currApp))
            self.switchApps.append((self._switchFrom, self._currApp))
            self._switchFrom = self._currApp
            self.numSwitches += 1
            if self.OPTIONS.verbose:
                print "*** SWITCHED FROM %s to %s" % self.switchApps[-1]

        self.latest_state = state

        if state in self._states:
            self._states[state] += 1
        else:
            self._states[state] = 1

        if len(self._current_transition) != 2:
            raise LogFileError("Two states without execution in between. <<%s>>" % str(self._current_transition))
        else:
            self._current_transition.append(state)
            self._current_transition = tuple(self._current_transition)
            if self._current_transition in self._transitions:
                self._transitions[self._current_transition] += 1
            else:
                self._transitions[self._current_transition] = 1
            self._numTrans += 1
            self._numTransOfCurrFileOnly += 1

            action = self._current_transition[1]
            # given componenttransitions by component
            for i in self._transitionsByComponent:
                if self._current_transition[0] is None:
                    break
                s1 = self._current_transition[0][i]
                s2 = self._current_transition[2][i]
                if s1 != s2:
                    self._transitionsByComponent[i].add(
                        (s1,self._current_transition[1],s2))
                    self._numTransitionsByComponent[i] += 1
            # all the componenttransitions
            for i in range(self._stateLen):
                if self._current_transition[0] is None:
                    break
                s1 = self._current_transition[0][i]
                s2 = self._current_transition[2][i]
                if s1 != s2:
                    self._componenttransitions.add( (i,s1,action,s2) )
                    self._numComponenttransitions += 1

            self._current_transition = [state]

    def parseASP(self, line):
        spStr = line.split('(Non-SleepState) StateProps: ',1)[1].strip()
        if spStr:
            sps = spStr[1:-1].split('" "')
            for sp in sps:
                self._asps.add( (self._latestStartAW,sp) )

    def parseExecuting(self, line):
        """Parses an "Executing" line.
        """
        executed_word = line.split('Executing: ',1)[-1].strip()

        devicePrefixAndWord = executed_word.split("/",1)
        if len(devicePrefixAndWord) > 1:
            self._device = devicePrefixAndWord[0]

        if len(self._current_transition) == 1:
            self._current_transition.append(executed_word)
        else:
            raise LogFileError("Two executions without state in between. <<%s>>" % str(self._current_transition))

        if 'ACTIVATES' in executed_word:
            self.parseExecutingActivates(line)
        elif ':start_aw' in executed_word:
            self.parseExecutingStartAW(line)
        elif ':end_aw' in executed_word or ':~end_aw' in executed_word:
            self.parseExecutingEndAw(line)
        else:
            self.parseExecutingMisc(line)

    def parseExecutingStartAW(self,line):
        aw1,sign,aw2,param = _RE_START_AW.search(line).groups()
        aw = aw1+aw2
        self._latestStartAW = aw

    def parseExecutingEndAw(self,line):
        awBegin, tildeOrNot, awEnd, param = _RE_END_AW.search(line).groups()
        if not self.OPTIONS.gen and self.isGenAW(awBegin+awEnd+param):
            return

        sign = (tildeOrNot == "")

        theAWDict = self._posAWs # usually here...
        if self.OPTIONS.neg:
            aw = awBegin + tildeOrNot + awEnd + param
            if sign == False:
                #...except if it's a negative aw and they're treated separately
                theAWDict = self._negAWs
        else:
            aw = awBegin + awEnd + param

        self._numAWs += 1
        self._numAWsOfCurrFileOnly += 1

        isNewAW = not theAWDict[aw]
        if isNewAW:
            theAWDict[aw] = 1
        else:
            theAWDict[aw] += 1
        if self.OPTIONS.verbose:
            self.printExecAWRow(aw,sign,isNewAW)

    def parseExecutingMisc(self,line):
        # unique switches (S1,S2): S1 -> SLEEPts -> WAKEtsWAKE -> S2
        if "Executing: SLEEPts" in line:
            self._switchFromState = self.latest_state
        elif "Executing: WAKEtsWAKE" in line:
            if self._switchFromState is not None:
                self._switchFrom = self._currApp
                module = _RE_WAKE.search(line).groups()[0]
                self._currApp = self.appOfModule(module)
            elif self._currApp is not None:
                # wake without sleep should only be possible at the start
                raise LogFileError("WAKEtsWAKE in a wrong place")
        # check if it's a kw execution, for which we may add delay 
        elif "Executing: kw_" in line or "Executing: ~kw_" in line:
            self._numKWs += 1
            self._numKWsOfCurrFileOnly += 1
            if self.OPTIONS.delay:
                self._delayByNow += self.OPTIONS.delay

    def parseExecutingActivates(self,line):
        """Parses an "X ACTIVATES Y" line.
        """
        a1, a2 = _RE_ACTIVATES.search(line).groups()
        if "/" in a1:
            # if there's a device name in the first, prepend it to the 2nd also
            a2 = a1.split("/",1)[0] + "/" + a2

        app1, app2 = None, None
        for an in self.appNames:
            if a1.startswith(an): app1 = an
            if a2.startswith(an): app2 = an

        if (app1 != app2):
            self._switchFrom = app1
            self._currApp = app2
            self._switchFromState = self.latest_state

    def appOfModule(self,module):
        if self._device:
            module = self._device+"/"+module

        for an in self.appNames:
            if module.startswith(an):
                return an
        return None

    def appOfAW(self,aw):
        for an in self.appNames:
            if aw.startswith(an):
                return an
        return None

    def negAWfromAW(self,aw):
        """Returns "negative" (~) version of aw."""
        awBegin, sign, awEnd, param = _RE_END_AW.search(aw).groups()
        return awBegin + "~" + awEnd + param


    def awCoverage(self):
        return nonZeroValuesRatio( self.allAWs() )

    def awCoverageOfApp(self,appname):
        return nonZeroValuesRatio( self.allAWsByApp(appname) )
        #return nonZeroValuesRatio( self.allAWsByApp()[appname] )

    def posAWsByApp(self,app):
        d = {}
        for pa in self._posAWsByApp[app]:
            d[pa] = self._posAWs[pa]
        return d

    def negAWsByApp(self,app):
        if not self.OPTIONS.neg:
            return {}
        d = {}
        for pa in self._negAWsByApp[app]:
            d[pa] = self._negAWs[pa]
        return d

    def allAWsByApp(self,app):
        d = {}
        for pa in self._posAWsByApp[app]:
            d[pa] = self._posAWs[pa]
        if self.OPTIONS.neg:
            for pa in self._negAWsByApp[app]:
                d[pa] = self._negAWs[pa]
        return d

    def awsByAppDict(self,appFunc):
        d = {}
        for an in self.appNames:
            d[an] = appFunc(an)
        return d

    def allAWs(self):
        if not self.OPTIONS.neg:
            return self._posAWs
        else:
            aa = {}
            aa.update(self._posAWs)
            aa.update(self._negAWs)
            return aa


    def varianceOfAppCov(self):
        if not self.appNames:
            return 0
        appCoverages = []
        for app in self.appNames:
            appCoverages.append( nonZeroValuesRatio(self.allAWsByApp(app)) )
        n = len(appCoverages)
        avg = sum(appCoverages) / float(n)
        variance = (1/float(n))*sum([(y-avg)*(y-avg) for y in appCoverages])
        return variance

    def stdDevOfAppCov(self):
        return math.sqrt( self.varianceOfAppCov() )


    def isGenAW(self,line):
        return ("TaskSwitcherGEN:end_awActivate" in line
                or "TargetSwitcher:end_awActivate" in line
                or "Synchronizer:end_aw" in line)


    ### print funcs:

    def __getColumns(self):
        return ("s", "kw", "aw", "awcov",
                "switches", "uniqswitches",
                "states", "uniqstates",
                "transitions", "uniqtransitions",
                "comptransitions", "uniqcomptransitions",
                "asp",
                "appcovstddev",
                "leastcoveredapp")\
                + tuple(["awcov(%s)"%a for a in self.appNames])\
                + tuple(["comptrans(%i)"%i for i in self._transitionsByComponent])

    def printPlotDataComment(self):
        print "# Log file:", self.filename
        print "# Title:", self.OPTIONS.title or self.filename
        print "# Test ran:", self._startTime.strftime('????-%m-%d %H:%M:%S')
        print "# Log read:", datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        print "# Apps:", " ".join(self.appNames)

        cols = self.__getColumns()

        self._colInd = dict( [(name,i) for i,name in enumerate(cols)] )
        self._numCols = len(cols)

        print "# Columns:",
        for i,x in enumerate(cols):
            print "%i:%s"% (i+1,x),
        print
        print

    def printCSVDataHeader(self):
        cols = self.__getColumns()
        self._colInd = dict( [(name,i) for i,name in enumerate(cols)] )
        self._numCols = len(cols)
        self.rowWriter.writerow(cols)

    def __getDataRow(self):
        switches = self.numSwitches
        states = sumOfValues(self._states)
        uniqStates = numberOfNonZeros(self._states)

        trans = sumOfValues(self._transitions)
        uniqTrans = numberOfNonZeros(self._transitions)

        appCoverages = []
        for appname in self.appNames:
            appCoverages.append( self.awCoverageOfApp(appname) )

        compTransitions = []
        for i,t in self._transitionsByComponent.iteritems():
            compTransitions.append( len(t) )

        uniqSwitches = len(self.switchTransitions)

        if appCoverages:
            covOfLeastCoveredApp = min(appCoverages)
        else:
            covOfLeastCoveredApp = 0

        return((self.elapsedMs()/1000.0, self._numKWs, self._numAWs,
                self.awCoverage(),
                switches, uniqSwitches,
                states, uniqStates,
                trans, uniqTrans,
                self._numComponenttransitions, len(self._componenttransitions),
                len(self._asps),
                self.stdDevOfAppCov(),
                covOfLeastCoveredApp)
            +
            tuple(appCoverages)
            +
            (tuple(compTransitions))
            )


    def printPlotDataRow(self):
        row = self.__getDataRow()
        print " ".join([str(i) for i in row])
        sys.stdout.flush()
        self.dataRows.append(row)

    def printCSVDataRow(self):
        row = self.__getDataRow()
        self.rowWriter.writerow(row)
        sys.stdout.flush()
        self.dataRows.append(row)

    def checkThatLogFileWasValid(self):
        sumStates = sumOfValues(self._states)
        if sumStates == 0:
            raise LogFileError("Not a single state found in the file.")

    def printTitle(self):
        print
        title = "%s (%i rows read)" % (self.filename,self._rowsRead)
        space = 60-len(title)
        print " "*(space/2) + title + " "*(space/2)
        print "-"*60

    def printSummary(self):
        self.printTitle()
        print "Running time: %.0f s" % (self.elapsedMs() / 1000),
        if self.OPTIONS.delay:
            delayTotal = timediffInMs(self._delayByNow) / 1000.0
            delayKw = timediffInMs(self.OPTIONS.delay) / 1000.0
            print "(including delay %.2f s/KW * %i KW's = %.0fs)" %(delayKw,self._numKWs,delayTotal)
        else:
            print 
        print "-"*60
        print "Total Action Word executions: %i" % self._numAWs
        print "Total Keyword executions: %i" % self._numKWs
        print "-"*60

        if self.OPTIONS.apps:
            if not self.OPTIONS.neg:
                awsByApp = self.awsByAppDict(self.posAWsByApp)
                awsByApp['Total'] = self.allAWs()
                printAppTable(awsByApp)
            else:
                print "Positive AW's"
                awsByApp = self.awsByAppDict(self.posAWsByApp)
                awsByApp['Total'] = self._posAWs
                printAppTable(awsByApp)

                print "Negative(~) AW's"
                awsByApp = self.awsByAppDict(self.negAWsByApp)
                awsByApp['Total'] = self._negAWs
                printAppTable(awsByApp)

                print "All AW's"
                awsByApp = self.awsByAppDict(self.allAWsByApp)
                awsByApp['Total'] = self.allAWs()
                printAppTable(awsByApp)
        else:
            if not self.OPTIONS.neg:
                printTable([self.allAWs()])
            else:
                print "Positive AW's:\n"
                printTable([self._posAWs])
                print "Negative(~) AW's:\n"
                printTable([self._negAWs])
                print "Total AW's:\n"
                printTable([self.allAWs()])

        sumStates = sumOfValues(self._states)
        sumTrans = sumOfValues(self._transitions)
        numTrans = numberOfNonZeros(self._transitions)
        uniqStates = numberOfNonZeros(self._states)
        print "Transitions executed: %i" % sumTrans
        print "Unique transitions: %i (%.2f%%)" % (numTrans, percentage(numTrans,sumTrans))

        print "Unique states visited: %i (%.2f%%)" % (uniqStates, percentage(uniqStates,sumStates))
        print "-"*60

        sumCompTrans = self._numComponenttransitions
        numCompTrans = len(self._componenttransitions)
        print "Component transitions executed: %i" % sumCompTrans
        print "Unique component transitions: %i (%.2f%%)" % (
            numCompTrans, percentage(numCompTrans,sumCompTrans) )
        print "-"*60




        switches = self.numSwitches
        if self.OPTIONS.apps:
            print "App switches: %i" % switches
            if switches:
                uniqSwitches = len(self.switchTransitions)
                print "Unique switches: %i (%.2f%%)"%(
                    uniqSwitches,100.0*uniqSwitches/switches)
            print "-"*60

        if self.OPTIONS.awexec:
            for v,e in reversed(groupByTimesExecuted(self.allAWs())):
                print
                print "----- AW's executed %i times (%i): -----" % (v,len(e))
                for x in e:
                    print x


    def printExecAWRow(self, aw, sign, isNew):
        s = "Executed"
        if isNew:
            s = "Executed NEW (%ith, %.2f%%)" % (
                numberOfNonZeros(self.allAWs()),self.awCoverage()*100)
        else: s += " old"
        if sign: s += " aw:"
        else: s += " ~aw: %s"
        print s.ljust(35),aw



def printExecAWHeader():
    print "-"*60
    print "Action words:"
    print "#        Elapsed(ms) AW-cov(%)    Action word"
    print "-"*60

def printTable(awDicts, colNames=None, spacing=10):
    if colNames is not None:
        print " "*23,
        print "".join([("%s"%cn[:spacing-1]).ljust(spacing) for cn in colNames])
    print "AW's in the model:     ",
    print "".join([("%i"%len((t))).ljust(spacing) for t in awDicts])

    print "AW executions:         ",
    print "".join([("%i"%sumOfValues(t)).ljust(spacing) for t in awDicts])

    print "Unique AW's executed:  ",
    print "".join([("%i"%numberOfNonZeros(t)).ljust(spacing) for t in awDicts])

    print "AW coverage:           ",
    print "".join([("%.2f%%"%(nonZeroValuesRatio(t)*100)).ljust(spacing) for t in awDicts])

    print "-"*60

def printAppTable(awsByApp, title=None):
    if title:
        print title
    awDicts = []
    coltitles = []
    for k,x in awsByApp.iteritems():
        coltitles.append(k.split('/')[-1])
        awDicts.append(x)
    printTable(awDicts, coltitles)


# main

def main(argv):
    logfiles, options = readSysArgs(argv)
    parser = LogParser(options)
    try:
        if options.combine:
            parser.readLogsAsOne(logfiles)
        else:
            for logfile in logfiles:
                parser.readLog(logfile)
    except KeyboardInterrupt:
        return False
    return True

if __name__ == "__main__":
    ok = main(sys.argv)
    sys.exit(0 if ok else -1)
